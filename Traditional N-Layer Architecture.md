สถาปัตยกรรมแบบดั้งเดิม 3 ชั้น หรือที่เรียกว่า "Traditional N-Layer architecture applications" [1] เป็นวิธีการจัดโครงสร้างแอปพลิเคชันที่นิยมใช้เพื่อจัดการกับความซับซ้อนของโค้ด [2] โดยจะแบ่งแอปพลิเคชันออกเป็นส่วนย่อยตามความรับผิดชอบหรือหน้าที่ [2]

**ลักษณะของสถาปัตยกรรม 3 ชั้นแบบดั้งเดิม:**
*   **การแบ่งชั้นเชิงตรรกะ (Logical Layers)**: สถาปัตยกรรมนี้แบ่งตรรกะของแอปพลิเคชันออกเป็นหลายชั้น โดยชั้นที่พบบ่อยที่สุดสามชั้นคือ [3]:
    *   **ชั้นส่วนติดต่อผู้ใช้ (UI - User Interface Layer)**: เป็นส่วนที่ผู้ใช้โต้ตอบด้วย รับคำขอจากผู้ใช้ [4] และนำเสนอผลลัพธ์กลับไป [4]
    *   **ชั้นตรรกะทางธุรกิจ (BLL - Business Logic Layer)**: เป็นส่วนที่มีตรรกะทางธุรกิจที่สำคัญที่สุดของแอปพลิเคชัน [4] โดยจะรับคำขอจากชั้น UI และจัดการกับกฎทางธุรกิจ [4]
    *   **ชั้นการเข้าถึงข้อมูล (DAL - Data Access Layer)**: เป็นส่วนที่รับผิดชอบในการเข้าถึงและจัดการข้อมูลในฐานข้อมูล [4]

*   **การสื่อสารระหว่างชั้น (Layer Communication)**:
    *   **ชั้น UI ควรโต้ตอบเฉพาะกับชั้น BLL เท่านั้น** [4]
    *   **ชั้น BLL จะเรียกใช้ DAL สำหรับคำขอเข้าถึงข้อมูล** [4]
    *   **ชั้น UI ไม่ควรส่งคำขอไปยัง DAL โดยตรง** [4]
    *   **ชั้น BLL ควรโต้ตอบกับการจัดเก็บข้อมูลผ่าน DAL เท่านั้น** [4]
    *   แนวคิดนี้ช่วยให้แต่ละชั้นมีหน้าที่รับผิดชอบที่ชัดเจน [4]

*   **ข้อดีของการแบ่งชั้นโดยทั่วไป**:
    *   **การจัดการความซับซ้อน**: ช่วยจัดการกับความซับซ้อนเมื่อแอปพลิเคชันมีขนาดใหญ่ขึ้น [2]
    *   **การจัดระเบียบโค้ด**: ทำให้โค้ดเป็นระเบียบและง่ายต่อการค้นหาฟังก์ชันการทำงาน [2]
    *   **การนำโค้ดกลับมาใช้ใหม่ (DRY - Don't Repeat Yourself)**: ฟังก์ชันการทำงานระดับต่ำทั่วไปสามารถนำกลับมาใช้ใหม่ได้ทั่วทั้งแอปพลิเคชัน ลดการเขียนโค้ดซ้ำ [5]
    *   **การบังคับใช้ข้อจำกัด**: แอปพลิเคชันสามารถบังคับใช้ข้อจำกัดว่าชั้นใดสามารถสื่อสารกับชั้นอื่นได้บ้าง ซึ่งช่วยให้เกิดการห่อหุ้ม (encapsulation) [6]
    *   **ความยืดหยุ่นในการเปลี่ยนแปลง**: หากชั้นมีการเปลี่ยนแปลงหรือถูกแทนที่ จะส่งผลกระทบต่อเฉพาะชั้นที่ทำงานร่วมกับมันเท่านั้น [6] เช่น การเปลี่ยนจากฐานข้อมูล SQL Server ไปยังกลยุทธ์การจัดเก็บข้อมูลบนคลาวด์ [7]
    *   **ความง่ายในการทดสอบ**: ทำให้ง่ายต่อการสลับการใช้งานเพื่อวัตถุประสงค์ในการทดสอบ โดยสามารถแทนที่ชั้นด้วยการใช้งานแบบจำลอง (fake implementations) ซึ่งทำให้การทดสอบเขียนง่ายขึ้นและรวดเร็วขึ้น [8]

*   **ข้อเสียของสถาปัตยกรรมแบบดั้งเดิม**:
    *   **การพึ่งพาแบบ Compile-time (Compile-time Dependencies)**: การพึ่งพาจะไหลจากบนลงล่าง (UI → BLL → DAL) [4] ซึ่งหมายความว่าชั้น BLL ซึ่งมักจะมีตรรกะที่สำคัญที่สุดในแอปพลิเคชัน จะขึ้นอยู่กับรายละเอียดการใช้งานการเข้าถึงข้อมูล (และบ่อยครั้งก็ขึ้นอยู่กับการมีอยู่ของฐานข้อมูล) [4]
    *   **ความยากในการทดสอบ BLL**: การทดสอบตรรกะทางธุรกิจในสถาปัตยกรรมดังกล่าวทำได้ยาก บ่อยครั้งต้องใช้ฐานข้อมูลสำหรับการทดสอบ [4] ปัญหานี้สามารถแก้ไขได้โดยใช้หลักการผกผันการพึ่งพา (Dependency Inversion Principle) [4]

*   **ความสัมพันธ์กับแอปพลิเคชัน Monolithic**:
    *   แอปพลิเคชันแบบ Monolithic คือแอปพลิเคชันที่รวมทุกอย่างไว้ในหน่วยเดียว [9]
    *   การแบ่งชั้นแบบ 3 ชั้นนี้เป็นวิธีทั่วไปในการแยกส่วนตรรกะภายในแอปพลิเคชันแบบ Monolithic [2, 10] ที่ถูกปรับใช้เป็นหน่วยเดียว [10]

*   **ชั้นเชิงตรรกะ vs. ชั้นเชิงกายภาพ (Logical Layers vs. Physical Tiers)**:
    *   **ชั้น (Layers)** หมายถึงการแยกตรรกะภายในแอปพลิเคชัน [3]
    *   **ระดับ (Tiers)** หมายถึงเป้าหมายการปรับใช้เชิงกายภาพที่แยกจากกันไปยังเซิร์ฟเวอร์หรือกระบวนการที่แยกจากกัน [3]
    *   เป็นไปได้และเป็นเรื่องปกติที่จะมีแอปพลิเคชันแบบ N-Layer ที่ปรับใช้ในระดับเดียว (single tier) [3]

*   **การปรับใช้ใน Azure**:
    *   แอปพลิเคชันแบบ Monolithic ที่ใช้สถาปัตยกรรมแบบ N-Layer สามารถปรับใช้บน Azure App Service ได้อย่างง่ายดาย และสามารถปรับขนาดได้ทั้งแบบ "scaling up" (เพิ่มทรัพยากรต่อโหนด) และ "scaling out" (เพิ่มจำนวนโหนด) เพื่อรองรับความต้องการที่เพิ่มขึ้น [10, 11] สามารถกำหนดค่าให้ปรับจำนวนโหนดโดยอัตโนมัติตามความต้องการและโหลดเฉลี่ย [11]
