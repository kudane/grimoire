Code smells หรือ "กลิ่นโค้ดที่ไม่ดี" คือ **ตัวบ่งชี้บางอย่างของปัญหาในโค้ด**ที่แสดงว่ามีบางสิ่งผิดปกติ [1, 2] โดยพื้นฐานแล้ว พวกมันคือเครื่องมือในการวินิจฉัยที่ใช้เมื่อพิจารณาการ Refactoring ซอฟต์แวร์เพื่อปรับปรุงการออกแบบ [2]

สิ่งสำคัญคือต้องให้ความสนใจกับ Code smells [1] อย่างไรก็ตาม **พวกมันไม่ใช่หลักคำสอน (dogmas)** แต่เป็นตัวบ่งชี้ว่าคุณค่าต่างๆ เช่น ความสามารถในการพัฒนา, ความถูกต้อง, ประสิทธิภาพในการผลิต และการปรับปรุงอย่างต่อเนื่องอาจตกอยู่ในความเสี่ยง [2, 3] สิ่งสำคัญคือต้องดำเนินการแก้ไขหาก Code smell ทำให้โค้ดไม่สามารถเปลี่ยนแปลงได้ [3]

**บริบทเป็นสิ่งสำคัญ** [2] สิ่งที่อาจไม่เหมาะสมในแอปพลิเคชันหนึ่งหรือส่วนหนึ่งของแอปพลิเคชัน อาจเหมาะสมในที่อื่น [2]

### **หมวดหมู่ทั่วไปของ Code Smells**

แหล่งข้อมูลระบุ Code smells หลายประเภท โดยแบ่งออกเป็นหมวดหมู่หลักๆ เพื่อช่วยในการทำความเข้าใจปัญหาที่แตกต่างกัน [4, 5]:

*   **Bloaters (โค้ดที่บวม):** โค้ดที่ขยายใหญ่ขึ้นจนยากต่อการจัดการ [4] ตัวอย่างเช่น `Long Method` (เมธอดที่ยาว) และ `Long Parameter List` (รายการพารามิเตอร์ที่ยาว) [4]
*   **Obfuscators (โค้ดที่ทำให้สับสน):** โค้ดที่ยากต่อการอ่านและเข้าใจ [4] ตัวอย่างเช่น `Comments` (คอมเมนต์) และ `Obscured Intent` (ความตั้งใจที่บดบัง) [4]
*   **Object Orientation Abusers (การใช้หลักการ OO ผิดพลาด):** การออกแบบเชิงวัตถุที่ผิดปกติ [4] ตัวอย่างเช่น `Alternative Class with Different Interfaces` (คลาสทางเลือกที่มีอินเทอร์เฟซต่างกัน) และ `Inappropriate Static` (Static ที่ไม่เหมาะสม) [4]
*   **Change Preventers (โค้ดที่ขัดขวางการเปลี่ยนแปลง):** โค้ดที่ทำให้การปรับเปลี่ยนในอนาคตเป็นเรื่องยาก [5] ตัวอย่างเช่น `Divergent Change` (การเปลี่ยนแปลงที่แยกออก) และ `Shotgun Surgery` (การผ่าตัดด้วยลูกซอง) [5]
*   **Dispensables (โค้ดที่เกินความจำเป็น):** โค้ดที่ไม่มีประโยชน์หรือไม่จำเป็น [5] ตัวอย่างเช่น `Duplicate Code` (โค้ดซ้ำซ้อน) และ `Dead Code` (โค้ดที่ตายแล้ว) [5]
*   **Couplers (โค้ดที่เชื่อมโยงกันมากเกินไป):** โค้ดที่มีการพึ่งพากันมากเกินไป [5] ตัวอย่างเช่น `Feature Envy` (อิจฉาฟีเจอร์) และ `Message Chains` (ลูกโซ่ข้อความ) [5]
*   **Test Smells (กลิ่นที่ไม่ดีในการทดสอบ):** ปัญหาที่เกี่ยวข้องกับการเขียนเทส [5] ตัวอย่างเช่น `Not Enough Tests` (การทดสอบไม่เพียงพอ) และ `Fragility` (ความเปราะบาง) [5]

### **ตัวอย่าง Code Smells ที่พบบ่อยและแนวทางแก้ไข**

นี่คือตัวอย่าง Code smells ทั่วไปบางส่วนพร้อมกับแนวทางแก้ไขที่แนะนำ:

*   **Afraid To Fail (กลัวความล้มเหลว):** เมื่อคุณเพิ่มการตรวจสอบพิเศษให้กับเมธอด (นอกขอบเขต) เพื่อหลีกเลี่ยงข้อยกเว้น [3]
    *   **แนวทางแก้ไข:** **เมธอดที่สามารถล้มเหลวควรรีบแจ้งความล้มเหลวอย่างชัดเจน** [3] ปัญหานี้มักเกิดขึ้นร่วมกับการตรวจสอบค่าว่าง (Null-Checks) [6]
*   **Boolean Blindness (ภาวะตาบอด Boolean):** อาร์กิวเมนต์ Boolean ของฟังก์ชันหลอกให้คุณเข้าใจผิดว่าค่า `true` หรือ `false` นั้นทำอะไรจริงๆ [7]
    *   **แนวทางแก้ไข:** **อย่าสร้างฟังก์ชันที่รับพารามิเตอร์ Boolean** [8] ข้อนี้มีการถกเถียงกันมาก โดยมีผู้ใช้บางรายแย้งว่าการใช้ Boolean นั้นจัดการได้ง่ายกว่าเมื่อมีการจัดทำเอกสารที่ดีหรือใช้ IDE สมัยใหม่ [9-12] ในขณะที่บางคนแนะนำให้ใช้ `enum` แทน Boolean เพื่อให้โค้ดขยายได้ง่ายขึ้น [13-16]
*   **Clever Code (โค้ดที่ฉลาดเกินไป):** การแสดงทักษะของคุณสามารถทำให้โค้ดซับซ้อนเกินไปอย่างรวดเร็ว แม้แต่สำหรับคุณเอง [8]
    *   **แนวทางแก้ไข:** **ทำให้โค้ดเรียบง่ายและเน้นที่ความสามารถในการอ่าน** [8]
*   **Data Clump (กลุ่มข้อมูล):** เมื่อคุณคิดว่าตัวแปรสองสามตัวไม่คุ้มค่าที่จะสร้างอินสแตนซ์แยกต่างหาก [4, 17]
    *   **แนวทางแก้ไข:** **สร้างคลาสแยกต่างหากเพื่อรวมตัวแปรเดี่ยวหลายตัว หรือแนะนำ Parameter Object** [17]
*   **Dead Code (โค้ดที่ตายแล้ว):** มักเกิดขึ้นในบล็อก `if-else` ขนาดใหญ่ ซึ่งมีเส้นทางมากมายจนไม่มีใครจำได้ว่าพวกมันถูกใช้เมื่อไหร่ [5, 17]
    *   **แนวทางแก้ไข:** **โค้ดที่ตายแล้วถูกบันทึกไว้ใน Git-History แล้ว ลบมันทันที** [17]
*   **Duplicated Code (โค้ดซ้ำซ้อน):** โค้ดที่ซ้ำซ้อน [5, 18] (แม้ว่า Dead code จะแย่กว่าก็ตาม [18])
    *   **แนวทางแก้ไข:** **อย่าทำซ้ำตัวเอง (Don't Repeat Yourself)** [18, 19]
*   **Fallacious Comment / "What" Comment (คอมเมนต์ที่ผิดพลาด / คอมเมนต์ "อะไร"):** การอธิบาย "อะไร" ในคอมเมนต์จะกลายเป็นการโกหกเมื่อเวลาผ่านไป [20, 21]
    *   **แนวทางแก้ไข:** **คอมเมนต์เฉพาะ "ทำไม" ของโค้ดของคุณเท่านั้น** [19, 20] ควรเป็นผู้ที่ตั้งข้อสงสัยเป็นพิเศษเมื่ออ่านโค้ดภายใต้ "What" comment [19, 21] อย่างไรก็ตาม มีผู้ใช้บางรายแย้งว่าคอมเมนต์ที่อธิบาย "อะไร" ที่ฟังก์ชันหรือคลาสทำนั้นจำเป็นเพื่อให้ผู้เรียกเข้าใจสัญญาที่ต้องรักษาไว้ [22, 23] และคอมเมนต์ที่แย่ก็ยังดีกว่าไม่มีคอมเมนต์เลย [23]
*   **Flag Argument (อาร์กิวเมนต์ธง):** การดำเนินการทั้งหมดของฟังก์ชัน/เมธอดขึ้นอยู่กับพารามิเตอร์ธง [24]
    *   **แนวทางแก้ไข:** **แยกฟังก์ชันออกเป็นฟังก์ชันที่แยกจากกัน** [24]
*   **Global Data (ข้อมูลส่วนกลาง):** การมี Global scope ที่ทุกคนเข้าถึงได้ ทำให้แอปพลิเคชันทั้งหมดของคุณกลายเป็น Global scope เดียวกัน [24]
    *   **แนวทางแก้ไข:** **ห่อหุ้มแอปพลิเคชันของคุณเป็นส่วนข้อมูลต่างๆ และเชื่อมโยงเท่าที่จำเป็นเท่านั้น** [24]
*   **Indecent Exposure (การเปิดเผยที่ไม่เหมาะสม):** การแสดงรายละเอียดภายในส่วนตัวของคลาสสู่โลกภายนอก [5, 25]
    *   **แนวทางแก้ไข:** **เปิดเผยเฉพาะสิ่งที่จำเป็นจริงๆ เพื่อโต้ตอบกับคลาสเท่านั้น** [25] อย่างไรก็ตาม ผู้ใช้บางรายมีความเห็นว่าการทำให้เมธอดส่วนตัวเป็น public แต่ใช้คอมเมนต์อธิบายถึงจุดประสงค์เดิมสามารถเป็นประโยชน์ได้ โดยเฉพาะเมื่อผู้อื่นอาจต้องการใช้เมธอดเหล่านั้น [26]
*   **Large Class (คลาสขนาดใหญ่):** การใส่โค้ดในคลาสที่มีอยู่ แทนที่จะสร้างคลาสใหม่ เมื่อตรรกะใหม่เพิ่มความรับผิดชอบอีกอย่าง [25]
    *   **แนวทางแก้ไข:** **ทำให้คลาสมีขนาดเล็กและรับผิดชอบเพียงสิ่งเดียว** [25]
*   **Long Method (เมธอดที่ยาว):** พวกมันเข้าใจยาก เปลี่ยนแปลงหรือขยายยาก และนักพัฒนาใช้เวลาอ่านโค้ดมากกว่าเขียน [4, 27]
    *   **แนวทางแก้ไข:** **ทำให้เมธอดสั้นและแม่นยำ** [27] ข้อนี้ก็มีการถกเถียงกัน ผู้ใช้บางรายแย้งว่าเมธอดที่ยาวกว่านั้นอ่านง่ายกว่าเพราะไม่ต้องข้ามไปมารอบๆ โค้ดเบสทั้งหมด [28, 29] แต่หลายคนก็ชี้ให้เห็นว่า IDE ที่ดีช่วยให้การกระโดดไปมาระหว่างเมธอดเป็นเรื่องง่าย และเมธอดที่ยาวมากๆ (เช่น 500 บรรทัด) มักจะสามารถแบ่งย่อยเป็นส่วนย่อยที่มีความหมายได้ [30-32]
*   **Long Parameter List (รายการพารามิเตอร์ที่ยาว):** 0-2 อาร์กิวเมนต์ดี, 3 อาร์กิวเมนต์ไม่ดี, 4 อาร์กิวเมนต์แย่ [4, 27]
    *   **แนวทางแก้ไข:** **ยึดติดกับ 0-2 อาร์กิวเมนต์เพื่อให้ฟังก์ชัน/เมธอดสะอาดและยึดติดกับ SRP** [27] ผู้ใช้บางรายไม่เห็นด้วย โดยเฉพาะอย่างยิ่งในภาษาที่รองรับ named parameters หรือเมื่อพารามิเตอร์จำนวนมากจำเป็นสำหรับการปรับแต่งและการใช้งานที่กว้างขวาง [33] รายการพารามิเตอร์ที่ยาวอาจบ่งชี้ว่าฟังก์ชันทำมากเกินไป [34]
*   **Magic Number (ตัวเลขมหัศจรรย์):** ค่าสุ่มที่ใช้ที่ไหนก็ได้เพื่อเปรียบเทียบเงื่อนไขบางอย่าง [35]
    *   **แนวทางแก้ไข:** **สร้างค่าคงที่เช่น `MAX_STUDENTS_IN_ROOM` เพื่อให้ตัวเลขเหล่านั้นมีความหมายที่ทุกคนเข้าใจได้** [35]
*   **Middle Man (คนกลาง):** หากคลาสของคุณมอบหมายคำขอไปยังคลาสอื่น คุณได้สร้างคนกลางขึ้นมา [5, 35]
    *   **แนวทางแก้ไข:** **รักษาสื่อกลางให้น้อยที่สุด** [36] ข้อนี้ก็มีการถกเถียงและชี้แจง ผู้เขียนแหล่งข้อมูลยอมรับว่าตนสับสนในการอธิบายในตอนแรก [22] โดยทั่วไปแล้ว การมีเลเยอร์แยกกัน (เช่น UI, Business, Data Access) นั้นเป็นสถาปัตยกรรมที่มีประโยชน์ และเลเยอร์ธุรกิจที่ทำหน้าที่เป็นคนกลางเพื่อสื่อสารกับเลเยอร์ข้อมูลนั้นเป็นแนวทางปฏิบัติที่ดี [37, 38]
*   **Null Check (การตรวจสอบค่าว่าง):** เมื่อโค้ดของคุณเต็มไปด้วยการตรวจสอบ `null` หรือ `undefined` [36]
    *   **แนวทางแก้ไข:** **สร้างคลาสเฉพาะที่จะถูกจัดการหากเกิด `null` หรือ `undefined` ขึ้น** [36]
*   **Primitive Obsession (ความหลงใหลใน Primitive):** หากคุณมีสตริงหรือจำนวนเต็มที่เลียนแบบแนวคิดที่เป็นนามธรรม เช่น วัตถุ [4, 39]
    *   **แนวทางแก้ไข:** **สร้างวัตถุที่เหมาะสมและจัดการพวกมันเหมือนวัตถุ** [39]
*   **Shotgun Surgery (การผ่าตัดด้วยลูกซอง):** การเปลี่ยนแปลงคลาสหลายคลาสโดยไม่จำเป็นสำหรับการปรับเปลี่ยนเพียงครั้งเดียว [5, 40]
    *   **แนวทางแก้ไข:** **หากบางสิ่งต้องเปลี่ยน ควรมีเพียงที่เดียวที่ต้องแก้ไข** [40]
*   **Speculative Generality (ความทั่วไปที่คาดเดา):** แม้ว่าคุณจะมีความตั้งใจที่ดีที่สุด แต่คุณสร้างคุณสมบัติพิเศษเพื่อเตรียมพร้อมสำหรับอนาคต แต่คุณสมบัติเหล่านั้นไม่เคยมีประโยชน์ [5, 41]
    *   **แนวทางแก้ไข:** **เขียนโค้ดเท่าที่คุณต้องการเพื่อแก้ปัญหาในปัจจุบันเท่านั้น** [41] ข้อนี้ก็มีการโต้แย้งอย่างมาก ผู้ใช้หลายคนไม่เห็นด้วยกับการห้ามการคาดการณ์ล่วงหน้าอย่างสมบูรณ์ และกล่าวว่าการวางโครงสร้างโค้ดที่สามารถขยายได้ง่ายในอนาคตนั้นเป็นสิ่งสำคัญและเป็น "ศิลปะ" ของการเขียนโปรแกรมสำหรับนักพัฒนาที่มีประสบการณ์ [34, 42-47]
*   **Uncommunicative Name (ชื่อที่ไม่สื่อสาร):** การตั้งชื่อตัวแปร ฟังก์ชัน และคลาสที่ทำให้เข้าใจผิด [4, 48]
    *   **แนวทางแก้ไข:** **คุณต้องการชื่อที่มีความหมายและไม่ทำให้เข้าใจผิด** [48]

โดยสรุปแล้ว Code smells เป็นตัวบ่งชี้ที่มีคุณค่าที่ช่วยให้นักพัฒนาปรับปรุงคุณภาพของโค้ด อย่างไรก็ตาม สิ่งสำคัญคือต้องพิจารณาบริบทและตระหนักว่าคำแนะนำบางอย่างอาจมีข้อยกเว้นหรือมีวิธีการแก้ไขที่แตกต่างกันออกไป [2, 45, 49, 50].
