Explicit Dependencies Principle 

หลักการพึ่งพาแบบชัดเจน เป็นแนวคิดสำคัญในการออกแบบซอฟต์แวร์ โดยเฉพาะอย่างยิ่งเมื่อใช้ Dependency Injection (DI) และ Inversion of Control (IoC) ใน ASP.NET Core หลักการนี้เน้นย้ำว่าโค้ดของคุณควรบอกให้ชัดเจนว่ามันต้องการอะไรในการทำงาน
การพึ่งพาคืออะไร?

Dependency (การพึ่งพา) คือวัตถุ (Object) ที่วัตถุอื่นต้องใช้ในการทำงาน
 * Implicit Dependencies (การพึ่งพาแบบซ่อนเร้น): คือการที่คลาสสร้างวัตถุที่มันต้องใช้ขึ้นมาเองโดยตรงภายในโค้ด เช่น การใช้ new MyDependency() ทำให้โค้ดผูกติดกันและแก้ไขได้ยาก เปรียบเหมือนคุณไปซูเปอร์มาร์เก็ตเองทุกครั้งที่คุณต้องการซื้อของ
 * Explicit Dependencies (การพึ่งพาแบบชัดเจน): คือการที่คลาสประกาศความต้องการวัตถุที่มันต้องใช้ผ่าน Constructor (เมื่อต้องการใช้ตลอดอายุของคลาส) หรือ พารามิเตอร์ของเมธอด (เมื่อต้องการใช้แค่ในเมธอดนั้นๆ) เปรียบเหมือนคุณสั่งของออนไลน์ แล้วมีคนมาส่งให้ถึงหน้าบ้าน คุณไม่ต้องไปเอง
ปัญหาของการพึ่งพาแบบซ่อนเร้น
การพึ่งพาแบบซ่อนเร้นทำให้เกิดปัญหาหลายอย่าง:
 * แก้ไขยาก: ถ้าคุณต้องการเปลี่ยนวิธีทำงานของวัตถุที่พึ่งพา คุณต้องไปแก้โค้ดทุกที่ที่สร้างวัตถุนั้นขึ้นมา
 * โค้ดกระจาย: ถ้าวัตถุที่พึ่งพามีการตั้งค่าซับซ้อน การตั้งค่าเหล่านั้นจะไปปรากฏอยู่ทั่วโค้ดของคุณ
 * ทดสอบยาก: การทดสอบโค้ดแบบ Unit Test ทำได้ยาก เพราะโค้ดผูกติดกับการทำงานจริง ทำให้จำลองหรือแยกส่วนการทดสอบได้ยาก
 * หาผลกระทบยาก: การจะรู้ว่าการเปลี่ยนแปลงโค้ดส่วนหนึ่งจะส่งผลกระทบต่อส่วนไหนบ้างทำได้ยาก
ประโยชน์ของการพึ่งพาแบบชัดเจน (และ Dependency Injection)
การใช้หลักการพึ่งพาแบบชัดเจนร่วมกับ Dependency Injection (DI) ช่วยแก้ปัญหาเหล่านี้ได้ โดย:
 * ใช้ Interface หรือ Base Class: เพื่อสร้าง "นามธรรม" ของวัตถุที่พึ่งพา ทำให้คุณสามารถสลับเปลี่ยนการทำงานได้ง่าย
 * ลงทะเบียนใน Service Container: ASP.NET Core มีระบบที่เรียกว่า Service Container (IServiceProvider) ซึ่งคุณสามารถบอกระบบได้ว่าต้องการให้สร้างวัตถุแบบไหนขึ้นมาเมื่อมีคนร้องขอ
 * Inject ผ่าน Constructor: เฟรมเวิร์กจะจัดการสร้างและส่งวัตถุที่จำเป็นเข้ามาให้ใน Constructor ของคลาสเอง
ผลลัพธ์คือ:
 * คลาสของคุณจะ ไม่จำเป็นต้องรู้รายละเอียด ของวัตถุที่มันใช้ รู้แค่ว่าต้องใช้ "อะไรบางอย่างที่ทำหน้าที่แบบนี้"
 * โค้ดจะ อ่านง่ายขึ้นและซื่อสัตย์มากขึ้น เพราะบอกชัดเจนว่าต้องการอะไร
 * ง่ายต่อการสลับเปลี่ยน การทำงานของวัตถุ เช่น ใช้แบบจำลองในการทดสอบ หรือใช้แบบจริงในการใช้งานจริง
ความสัมพันธ์กับหลักการอื่น
หลักการพึ่งพาแบบชัดเจนมีความเกี่ยวโยงกับ:
 * Dependency Inversion Principle (DIP): หลักการที่บอกว่าโค้ดส่วนบน (ระดับสูง) ไม่ควรขึ้นอยู่กับโค้ดส่วนล่าง (ระดับต่ำ) แต่ทั้งคู่ควรขึ้นอยู่กับนามธรรม (สิ่งที่จับต้องไม่ได้)
 * Hollywood Principle: "Don't call us, we'll call you." (ไม่ต้องเรียกหาเรา เดี๋ยวเราเรียกหาเอง) ซึ่งสื่อถึงแนวคิด Inversion of Control (การกลับด้านการควบคุม)
ตัวอย่างการพึ่งพา
 * แบบซ่อนเร้น: คลาสสร้าง MyDependency ขึ้นมาใช้เองโดยตรงในโค้ด ทำให้ถ้าจะเปลี่ยนต้องแก้ที่คลาสนี้
 * แบบชัดเจน: กำหนด IMyDependency (Interface) ขึ้นมา แล้วให้ MyDependency ไป implement Interface นั้น จากนั้นก็ "Inject" IMyDependency เข้าไปใน Constructor ของคลาสแทน ทำให้ถ้าอยากเปลี่ยนไปใช้ MyDependency2 ก็แค่ไปเปลี่ยนการตั้งค่าที่ Service Container โดยไม่ต้องแก้โค้ดของคลาสที่เรียกใช้เลย
แนวทางปฏิบัติที่ดีในการออกแบบบริการใน ASP.NET Core
เมื่อใช้ DI ควรปฏิบัติดังนี้:
 * หลีกเลี่ยง Static Class และ Global State: ให้ใช้บริการแบบ Singleton (วัตถุเดียวใช้ได้ทั่วแอป) แทน
 * หลีกเลี่ยงการสร้างวัตถุเองโดยตรง: ให้ DI Container จัดการให้
 * ออกแบบบริการให้เล็กและเฉพาะเจาะจง: ถ้าคลาสหนึ่งมีสิ่งที่ต้อง Inject เข้ามาเยอะเกินไป อาจหมายความว่าคลาสนั้นทำหลายอย่างเกินไป ควรแยกย่อยออก
 * ปล่อยให้ Container จัดการการกำจัดวัตถุ (Disposal): ถ้า Container สร้างวัตถุที่มี IDisposable มันจะจัดการกำจัดให้เอง คุณไม่ควรเรียก Dispose เอง
 * หลีกเลี่ยง Service Locator Pattern: อย่าไปเรียก GetService เพื่อขอวัตถุจาก Container ตรงๆ ถ้ามีทางเลือกอื่น
 * หลีกเลี่ยงการเข้าถึง HttpContext แบบ Static: ใช้ DI เพื่อ Inject HttpContext แทน
 * ระมัดระวังการเรียก BuildServiceProvider ใน ConfigureServices: อาจทำให้เกิดปัญหาได้ ควรใช้วิธีอื่น เช่น Options pattern
การใช้ Explicit Dependencies Principle ทำให้โค้ดของคุณ สะอาดขึ้น ทดสอบได้ง่ายขึ้น และยืดหยุ่นต่อการเปลี่ยนแปลง ซึ่งเป็นสิ่งสำคัญในการสร้างแอปพลิเคชัน ASP.NET Core ที่ดีและสามารถบำรุงรักษาได้ในระยะยาว
มีคำถามเพิ่มเติมเกี่ยวกับหลักการนี้ไหม?
